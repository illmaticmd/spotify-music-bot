import spotipy
from spotipy.oauth2 import SpotifyOAuth
import datetime
from collections import Counter
import random
import os
import json # ADD THIS IMPORT
from dotenv import load_dotenv

load_dotenv()

# --- NEW AUTHENTICATION LOGIC FOR CLOUD ---
# 1. Check if we are in the cloud (using a custom Env Var 'SPOTIPY_CACHE_DATA')
cache_data = os.environ.get('SPOTIPY_CACHE_DATA')

# 2. Define a custom CacheHandler that reads from that Env Var
class MemoryCacheHandler(spotipy.cache_handler.CacheHandler):
    def get_cached_token(self):
        if cache_data:
            return json.loads(cache_data)
        return None
    
    def save_token_to_cache(self, token_info):
        # In a real cloud app, you'd save this to a database (DynamoDB/Firestore)
        # For this simple bot, we just print it so you can manually update if needed
        print("New token generated! Update your Env Var with this:")
        print(json.dumps(token_info))

# 3. Choose the handler
# If we have the Env Var, use Memory. If not (local), use the default file.
handler = MemoryCacheHandler() if cache_data else None

scope = "user-top-read playlist-modify-public"
sp = spotipy.Spotify(auth_manager=SpotifyOAuth(
    scope=scope, 
    cache_handler=handler # Inject our custom handler
))
# ------------------------------------------

def get_top_genres():
    print("--- STEP 1: Analyzing Your Taste Profile ---")
    try:
        # Get your top artists (includes Genre data!)
        results = sp.current_user_top_artists(limit=20, time_range='short_term')
        
        # Fallback if short term is empty
        if not results['items']:
            results = sp.current_user_top_artists(limit=20, time_range='long_term')
            
        if not results['items']:
            print("   No history found. Defaulting to 'Pop'.")
            return ['pop']

        # Extract all genres from all artists
        all_genres = []
        for artist in results['items']:
            all_genres.extend(artist['genres'])
            
        # Count them to find your "Top 3"
        # This is basic text analytics
        genre_counts = Counter(all_genres)
        top_3 = [genre for genre, count in genre_counts.most_common(20)]
        
        print(f"   Your Top Genres: {top_3}")
        return top_3
        
    except Exception as e:
        print(f"   Error analyzing taste: {e}")
        return ['pop', 'rap'] # Safety fallback

def scout_genre_gems(target_genres):
    print(f"\n--- STEP 2: Hunting for New Music (1990-2000) ---")
    discovered_ids = []
    
    # We want "Fresh" music
    year_query = "year:1990-2000"
    
    for genre in target_genres:
        print(f"   Scouting for new '{genre}' tracks...")
        query = f"{year_query} genre:\"{genre}\""
        
        try:
            # Search for 20 tracks in this genre
            results = sp.search(q=query, limit=10, type='track')
            tracks = results['tracks']['items']
            
            for t in tracks:
                # FILTER: Skip extremely popular songs (Let's find gems, not hits)
                # Popularity is 0-100. We'll skip anything over 80 (Mainstream hits)
                if t['popularity'] > 0:
                    discovered_ids.append(t['id'])
                    print(f"     -> Found: {t['name']} by {t['artists'][0]['name']} (Pop: {t['popularity']})")
                    
        except Exception as e:
            print(f"     Search failed for {genre}: {e}")
            continue
            
    # Shuffle so the playlist isn't just one genre block
    random.shuffle(discovered_ids)
    
    # Remove duplicates
    return list(set(discovered_ids))

def create_genre_playlist(track_ids):
    if not track_ids:
        print("No tracks found.")
        return

    user_id = sp.me()['id']
    date_str = datetime.date.today().strftime('%Y-%m-%d')
    playlist_name = f"Bot Finds (Genre Hunter) - {date_str}"
    
    try:
        playlist = sp.user_playlist_create(user_id, playlist_name, description="Generated by Python Metadata Filtering")
        
        # Add in chunks of 50 just to be safe
        for i in range(0, len(track_ids), 50):
            sp.playlist_add_items(playlist['id'], track_ids[i:i+50])
            
        print(f"\n--- SUCCESS! Created '{playlist_name}' with {len(track_ids)} songs. ---")
    except Exception as e:
        print(f"Error creating playlist: {e}")

if __name__ == "__main__":
    # 1. Get Top Genres
    my_genres = get_top_genres()
    
    # 2. Scout New Music in those Genres
    new_gems = scout_genre_gems(my_genres)
    
    # 3. Save
    create_genre_playlist(new_gems)